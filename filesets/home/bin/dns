#! /bin/env bash
source '/home/nestor/bin/std.lib'

# ---

{ # -- Help Text -- #

	cat <<-EOF | store-as usage
		Usage: $( script-name ) get [record|ip|ttl] [--for NAME]
		       $( script-name ) set IP              [--for NAME]
		       $( script-name ) del                 [--for NAME]

		Convenience handler for managing GCP-related DNS 'A' records.
		NAME may be a hostname ('sync') or a full dotted domain name.
		When no NAME is given, one is constructed for the current host.
		DNS records are given as JSON; IPs and TTLs are given in plain text.

		A "get" with no "record"/"ip"/"ttl" will return a record by default.


		Mandatory arguments to long options are mandatory for short options too.
		  --help                    Show this help text.


		Exit Status:
		  0  if OK,
		  1  if invalid option,
		  2  if no record found.
	EOF

}

# ---

{ # -- Parameter Processing: Options -- #

	# Set defaults.

	name="$( vm-name )"

	# --
	# --

	CHAR_OPTS=''
	LONG_OPTS='help,for:,name:'

	set-params
	while true; do
		option="$1" && shift
		case "$option" in
			(--help) exit-out "$usage" ;;
			(--) break ;;  # No more options.


			(--for|--name)
				name="$1" && shift
				;;

		esac
	done

}

{ # -- Parameter Processing: Positionals -- #

	[ "$#" == 0 ] && error-out 1 'insufficient parameters'


	# ---

	dns_zone='vm-names'
	dns_domain='.custodio.app'

	domain_name="${name%.}"
	domain_name="${domain_name%"$dns_domain"}"
	domain_name="${domain_name}${dns_domain}."

	{ # -- Helpers -- #

		function dns { gcloud dns record-sets "$@" --zone="$dns_zone" ;}

		function record-for {
			local domain_name="$1" && shift
			dns list --filter="(name:'${domain_name}') AND (type:'A')"  --format='json' | json '.[0]'
		}

	}

	# ---

	directive="$1" && shift
	case "$directive" in

		(get)

			response_type='record'

			[ "$#" == 1 ] && response_type="$1" && shift
			[ "$#" == 0 ] || error-out 1 'too many parameters'


			record-for "$domain_name" | store-as record
			[ -n "$record" ] || error-out 2 'no DNS record found'

			case "$response_type" in
				(record) json "$record" '.'           ;;
				(ip    ) json "$record" '.rrdatas[0]' ;;
				(ttl   ) json "$record" '.ttl'        ;;

				*) error-out 1 'unexpected GET param' ;;
			esac
			;;


		(set|update)

			[ "$#" -lt 1 ] && error-out 1 'no new IP given'
			[ "$#" -gt 1 ] && error-out 1 'too many parameters'

			new_ip="$1" && shift
			new_ttl='60'

			if [ -n "$( record-for "$domain_name" )" ]
				then dns update "$domain_name" --type='A' --rrdatas="$new_ip" --ttl="$new_ttl" &> /dev/null
				else dns create "$domain_name" --type='A' --rrdatas="$new_ip" --ttl="$new_ttl" &> /dev/null
			fi
			;;


		(del|delete)

			[ "$#" == 0 ] || error-out 1 'too many parameters'

			[ -n "$( record-for "$domain_name" )" ] && dns delete "$domain_name" --type='A' &> /dev/null
			;;


		*)
			error-out 1 'invalid option(s)'
			;;

	esac

}

# ---
# ---


noop  # Positional parameter processing has already taken care of everything.
