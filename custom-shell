#! /bin/bash
shopt -s lastpipe

# ---

# Set shell niceties.
#
shopt -s autocd checkwinsize globstar interactive_comments lastpipe no_empty_cmd_completion sourcepath


# Executable search order should be: - the current directory
#                                    - "${HOME}/bin"
#                                    - "${HOME}/bin/vendor"
#                                    - "${HOME}/.nodes/bin"
#                                    - "${HOME}/.yarn/bin"
#                                    - snap packages
#                                    - native packages
#                                    - the current directory's "./bin"
#
export PATH=".:${HOME}/bin:${HOME}/bin/vendor:${HOME}/.nodes/bin:${HOME}/.yarn/bin:/snap/bin:${PATH}:./bin"


# Helper for absolute paths to real binaries.
#
function real { realpath "$( which "$@" )" ;}


# Explicitly set our language and sorting collation of choice.
#
export LANG=en_US.UTF-8
export LC_COLLATE=en_US.UTF-8


# Explicitly set our $EDITOR of choice.
#
export EDITOR="$( real hx )"
function helix { "$EDITOR" "$@" ;}
function :     { "$EDITOR" "$@" ;}


# Postgres should connect to host "postgres" by default.
# (https://www.postgresql.org/docs/current/libpq-envars.html)
#
export PGHOST='postgres'




# Set sensible tooling defaults and shortcuts.

  # bat

  # It's nice to have a 1-char name for something
  # that will properly page/colorize man/help text.
  #
  function m { man "$@" | bat --plain --language='man' ; }
  function h { "$@" --help | bat --plain --language='help' ; }


  # cd

  # Make it easier to `cd` into common locations.
  #
  export CDPATH=".:${HOME}"


  # dotdrop

  # Ensure `dotdrop` can find its config file.
  #
  export DOTDROP_CONFIG="${HOME}/links/dotdrop-config.yaml"

  # All hosts share the same `dotdrop` profile.
  #
  export DOTDROP_PROFILE='global'


  # eget

  # Make sure `eget` knows where to download binaries to
  # *and* knows where to look for existing binaries when
  # determining timestamps for `--upgrade-only` purposes.
  #
  export EGET_BIN="${HOME}/bin/vendor"


  # fzf

  fzf_keybinding_spec="ctrl-i:up,ctrl-k:down,space:toggle,ctrl-space:toggle"

  fzf_preview_command="file --brief --mime-type -- {} | starts-with 'text/'   \
                       && bat --force-colorization --line-range='1:200' -- {} \
                       || echo '(non-text content)'"

  export FZF_DEFAULT_COMMAND="fd --hidden --exclude='.git/' --color='always'"
  export FZF_DEFAULT_OPTS="--ansi                               \
                           --cycle                              \
                           --header=''                          \
                           --info='inline'                      \
                           --keep-right                         \
                           --layout='reverse'                   \
                                                                \
                           --bind='${fzf_keybinding_spec}'      \
                                                                \
                           --preview-window='hidden'            \
                           --preview=\"${fzf_preview_command}\" "


  # git / lazygit

  function g { lazygit ;}

  function gadd        { git add                               "$@" ;}
  function gblame      { git blame -w --minimal --color-by-age "$@" ;}
  function gbranch     { git branch                            "$@" ;}
  function gcheckout   { git checkout                          "$@" ;}
  function gcherrypick { git cherry-pick                       "$@" ;}
  function gconfig     { git config                            "$@" ;}
  function gclone      { git clone                             "$@" ;}
  function gcommit     { git commit                            "$@" ;}
  function gdiff       { git diff                              "$@" ;}
  function gfetch      { git fetch                             "$@" ;}
  function ggraph      { git log --oneline --decorate --graph  "$@" ;}
  function ginit       { git init                              "$@" ;}
  function glog        { git log                               "$@" ;}
  function gmerge      { git merge --no-ff                     "$@" ;}
  function gmove       { git mv                                "$@" ;}
  function gmv         { git mv                                "$@" ;}
  function gpatch      { git apply                             "$@" ;}
  function gpop        { git stash pop                         "$@" ;}
  function gpull       { git pull                              "$@" ;}
  function gpush       { git push                              "$@" ;}
  function grebase     { git rebase                            "$@" ;}
  function gremote     { git remote                            "$@" ;}
  function greset      { git reset                             "$@" ;}
  function gstage      { git add                               "$@" ;}
  function gstash      { git stash                             "$@" ;}
  function gstatus     { git status                            "$@" ;}
  function gtag        { git tag                               "$@" ;}
  function gtrack      { git add                               "$@" ;}
  function gunchange   { git checkout HEAD                     "$@" ;}
  function gundelete   { git checkout HEAD                     "$@" ;}
  function gunstage    { git reset                             "$@" ;}
  function guntrack    { git rm -r --cached                    "$@" ;}

  function gdeploy {
    local remote="${1:-production}"
    local branch="$( gbranch --show-current )"

    local prompt='Deploy branch "\033[33;1m%s\033[0m" to remote "\033[31;1m%s\033[0m"? (y/N) '
    local confirmation='n'

    gremote 2> /dev/null | hasline "$remote" || return 1

    printf "$prompt" "$branch" "$remote"; read confirmation
    [ "$( tr 'A-Z' 'a-z' <<< "$confirmation" )" == 'y' ] || return 2

    gpush "$remote" "${branch}:main" && ding-me
  }


  # grep

  function grep { "$( real grep )" -P --color=auto "$@" ;}


  # heroku

  function k { heroku "$@" ;}


  # lazydocker

  function lazydocker {
    which docker &> /dev/null || sudo apt install -qqy docker.io

    # We don't want the function name back, so `which` is a must.
    # shellcheck disable=SC2230
    #
    sudo "$( which lazydocker )" "$@"
  }


  # less

  function less { "$( real less )" --quit-if-one-screen --LONG-PROMPT --LINE-NUMBERS --RAW-CONTROL-CHARS --silent --chop-long-lines --shift=1 "$@" ;}


  # ls

  function ls {
    # Note we're `eval`'ing this because we're building out the `--hide` params.
    #
    eval                                                                                       \
    "$( real ls )" -ohH --color='auto'                                                         \
                   $( sed -r -e 's|(.*)|--hide="\1"|' < ~/.hidden | tr "\n" ' ' )              \
                   --group-directories-first --time-style='long-iso' --quoting-style='literal' \
                   "$@"
  }
  function la {
    "$( real ls )" -ohH --color='auto' --almost-all                                            \
                   --group-directories-first --time-style='long-iso' --quoting-style='literal' \
                   "$@"
  }


  # pgcli

  function pgcli { "$( real pgcli )" --pgclirc="~/.config/pgcli/config" "$@" ;}


  # rg

  function rg { "$( real rg )" --engine="pcre2" --color=auto --follow "$@" ;}


  # shellcheck

  # `shellcheck` is a bit of a pain to use on directories that
  # include both executable scripts and data files, as it generates
  # a ton of false positive warnings for the non-script files. This
  # shim filters non-files and non-executables out of the parameter
  # list.

  function shellcheck {
    declare -a args=("$@")
    declare -a executables

    for (( i=0; i < "${#args[*]}"; i++ )); do
      # We only want to run our sanity checks on non-option arguments.
      # Anything that begins with a '-' gets passed through unlatered.

      if [ "$( head -c1 <<< "${args[$i]}" )" != '-' ]; then
        [ -d "${args[$i]}" ] && continue  # Skip directories.
        [ -x "${args[$i]}" ] || continue  # Only keep executables.
        head -n1 "${args[$i]}" | has '#!' || continue  # Only keep shebang'ed files.
      fi

      executables+=("${args[$i]}")
    done

    # We don't want the function name back, so `which` is a must.
    # shellcheck disable=SC2230
    #
    "$( real shellcheck )" "${executables[@]}"
  }


  # tree

  function list { tree -lR --dirsfirst --sort=version "$@" ;}


  # watch

  # We have to define our own `watch` replacement to allow for
  # use of functions.

  function mira {
    local watch_interval
    [ -n "$1" ] && [ -z "${1//[0-9]/}" ] && interval="$1" && shift
    [ "$#" -gt 0 ] && watch --color --interval="${watch_interval:-10}" --exec -- bash -ci "$* ; exit &> /dev/null"
  }




# Filesystem manipulation niceties.

function md { mkdir "$@" ;}
function rd { rmdir "$@" ;}

function ...   { cd ../..       ;}
function ....  { cd ../../..    ;}
function ..... { cd ../../../.. ;}

function mkcd { mkdir -p "$1" && cd "$1"; }

function mirror {
  rsync --verbose                               \
        --recursive --force                     \
        --whole-file --delete-during            \
        --links --perms --executability --times \
        "$@"
}

function break-out-of-links {
  local pwd="$( pwd -P )"
  local link_root="${HOME}/links/"
  starts-with "$link_root" <<< "$pwd" && cd "$( sed -e "s|${link_root}|/|" <<< "$pwd" )"
}




# Set the prompt.
#
prompt_setter="${HOME}/bin/prompt.src"
[ -r "$prompt_setter" ] && source "$prompt_setter"


# Load additional VM-specific customizations.
#
vm_customization_home="${HOME}/vm-scripts/$( hostname )"
if [ -d "$vm_customization_home" ]; then
  export PATH="${PATH}:${vm_customization_home}/bin"

  vm_customization_file="${vm_customization_home}/custom-shell"
  [ -r "$vm_customization_file" ] && source "$vm_customization_file"
fi


# Load Dev-specific tooling (ENV/language helpers).
#
export DEV_ROOT="${HOME}/dev"
dev_helpers="${HOME}/bin/dev.src"
[ -r "$dev_helpers" ] && source "$dev_helpers"


# New windows/panes opened from within a symlinked location will show up within ~/links,
# so we're breaking out of those by default on new shells to avoid having to do it manually.
#
break-out-of-links


true  # Never start a shell with a non-0 status on the prompt.
